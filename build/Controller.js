// Generated by CoffeeScript 1.6.3
(function() {
  var global,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  global = this;

  this.Controller = (function(_super) {
    __extends(Controller, _super);

    function Controller() {
      var self;
      this.fps;
      this.timer;
      this.paused;
      this.view;
      this.pupup;
      this.viewForRing = new Hash;
      this.viewForApple = new Hash;
      self = this;
      window.addEventListener("load", function() {
        console.log("controller dom loaded", self);
        return self.didLoad();
      });
      window.addEventListener("unload", function() {
        return self.didUnload();
      });
      Controller.__super__.constructor.call(this);
    }

    Controller.prototype.init = function() {
      return this.set('apples', []);
    };

    Controller.prototype.didLoad = function() {
      var self,
        _this = this;
      self = this;
      self.view = document.getElementById("kukacdiv");
      self.view.style.position = "relative";
      self.popup = document.getElementById("pupup");
      this.addObserver('paused', function(key, change) {
        if (self.get('paused')) {
          return self.showMessage('press a button to continue...');
        } else {
          return self.hideMessage();
        }
      });
      this.addObserver('apples', function(key, change) {
        var apple, _fn, _i, _j, _len, _len1, _ref, _ref1, _results;
        _ref = change.added;
        _fn = function(apple) {
          return self.addViewForApple(apple);
        };
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          apple = _ref[_i];
          _fn(apple);
        }
        _ref1 = change.removed;
        _results = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          apple = _ref1[_j];
          _results.push((function(apple) {
            return self.removeViewForApple(apple);
          })(apple));
        }
        return _results;
      });
      this.addObserver('kukac', function(key, change) {
        return console.log('kukac changed: ', change["new"]);
      });
      self.fps = 6;
      self.bounds = new Bounds(new Vector(0, 0), new Vector($(self.view).width(), $(self.view).height()));
      self.reset();
      global.document.addEventListener("keydown", function(event) {
        var _ref;
        if ((_ref = event.keyIdentifier) === "U+0020" || _ref === "Left" || _ref === "Right" || _ref === "Up" || _ref === "Down") {
          event.preventDefault();
        }
        switch (event.keyIdentifier) {
          case "Left":
            return self.kukac.set('direction', new Vector(-1, 0));
          case "Right":
            return self.kukac.set('direction', new Vector(1, 0));
          case "Up":
            return self.kukac.set('direction', new Vector(0, -1));
          case "Down":
            return self.kukac.set('direction', new Vector(0, 1));
          case "U+0020":
            return self.togglePause();
          default:
            if (_this.get('paused')) {
              return _this.startGameloop();
            }
        }
      });
      this.stopGameloop();
      this.showMessage('Press a button to start!');
      return this.dropAnApple();
    };

    Controller.prototype.didUnload = function() {
      var self;
      console.log("unload");
      self = this;
      return this.stopGameloop();
    };

    Controller.prototype.dropAnApple = function() {
      var apple, height, randomx, randomy, self, step, width;
      self = this;
      apple = new Apple;
      step = 20;
      width = self.bounds.getWidth() - step;
      height = self.bounds.getHeight() - step;
      randomx = Math.random();
      randomy = Math.random();
      apple.set('position', new Vector(Math.round(randomx * width / step) / Math.round(width / step) * width + step / 2, Math.round(randomy * height / step) / Math.round(height / step) * height + step / 2));
      return self.addTo('apples', apple);
    };

    Controller.prototype.gameloop = function() {
      var apple, dist, ring, self, _i, _j, _len, _len1, _ref, _ref1, _results;
      self = this;
      self.kukac.move();
      self.updateView();
      /*   GAME OVER*/

      if (!this.bounds.contains(self.kukac.get("position"))) {
        this.gameOver();
      }
      _ref = self.kukac.rings.slice(1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        ring = _ref[_i];
        dist = ring.get('position').dist(self.kukac.get('position'));
        if (dist < self.kukac.get('width')) {
          this.gameOver();
        }
      }
      /*   EAT*/

      _ref1 = self.get('apples');
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        apple = _ref1[_j];
        _results.push((function(apple) {
          var dst;
          dst = apple.get('position').dist(self.kukac.get('position'));
          if (dst < apple.get('size') / 2 + self.kukac.get('width') / 2) {
            self.kukac.grow();
            self.removeFrom('apples', apple);
            return self.dropAnApple();
          }
        })(apple));
      }
      return _results;
    };

    Controller.prototype.addViewForApple = function(apple) {
      var applePos, circle, self;
      self = this;
      circle = document.createElement("div");
      $(circle).addClass('apple');
      circle.style.position = "absolute";
      applePos = apple.get('position');
      circle.style.top = applePos.y - apple.get('size') / 2 + "px";
      circle.style.left = applePos.x - apple.get('size') / 2 + "px";
      circle.style.width = apple.get('size') + "px";
      circle.style.height = apple.get('size') + "px";
      self.viewForApple.set(apple, circle);
      return $(self.view).prepend(circle);
    };

    Controller.prototype.removeViewForApple = function(apple) {
      var element, self;
      self = this;
      element = self.viewForApple.getValue(apple);
      $(element).remove();
      return self.viewForApple.set(apple, void 0);
    };

    Controller.prototype.updateView = function() {
      var newRings, oldRings, oldring, ring, self, _fn, _fn1, _fn2, _fn3, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _results;
      self = this;
      /* RINGS*/

      newRings = [];
      _ref = self.kukac.rings;
      _fn = function(ring) {
        var RingHasAssociatedView;
        RingHasAssociatedView = self.viewForRing.getValue(ring) ? true : false;
        if (!RingHasAssociatedView) {
          return newRings.push(ring);
        }
      };
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        ring = _ref[_i];
        _fn(ring);
      }
      oldRings = [];
      _ref1 = self.viewForRing.getKeys();
      _fn1 = function(oldring) {
        var ViewHasAssociatedRing;
        ViewHasAssociatedRing = self.kukac.rings.indexOf(oldring) >= 0 ? true : false;
        if (!ViewHasAssociatedRing) {
          return oldRings.push(oldring);
        }
      };
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        oldring = _ref1[_j];
        _fn1(oldring);
      }
      _fn2 = function(ring) {
        var circle;
        circle = document.createElement("div");
        $(circle).addClass('warmring');
        circle.style.position = "absolute";
        circle.style.width = ring.get('radius') * 2 + "px";
        circle.style.height = ring.get('radius') * 2 + "px";
        self.viewForRing.set(ring, circle);
        return $(self.view).prepend(circle);
      };
      for (_k = 0, _len2 = newRings.length; _k < _len2; _k++) {
        ring = newRings[_k];
        _fn2(ring);
      }
      _fn3 = function(oldring) {
        var element;
        element = self.viewForRing.getValue(oldring);
        $(element).fadeOut({
          duration: 500,
          complete: function() {
            return $(this).remove();
          }
        });
        return self.viewForRing.set(oldring, void 0);
      };
      for (_l = 0, _len3 = oldRings.length; _l < _len3; _l++) {
        oldring = oldRings[_l];
        _fn3(oldring);
      }
      _ref2 = self.kukac.rings;
      _results = [];
      for (_m = 0, _len4 = _ref2.length; _m < _len4; _m++) {
        ring = _ref2[_m];
        _results.push((function(ring) {
          var circle, ringPos;
          circle = self.viewForRing.getValue(ring);
          ringPos = ring.get('position');
          circle.style.left = ringPos.x - ring.get('radius') + "px";
          return circle.style.top = ringPos.y - ring.get('radius') + "px";
        })(ring));
      }
      return _results;
    };

    Controller.prototype.showMessage = function(message) {
      $(self.popup).fadeIn();
      return $(self.popup).html(message);
    };

    Controller.prototype.hideMessage = function() {
      return $(self.popup).fadeOut();
    };

    Controller.prototype.togglePause = function() {
      console.log('toggle pause');
      if (this.get('paused')) {
        return this.startGameloop();
      } else {
        return this.stopGameloop();
      }
    };

    Controller.prototype.reset = function() {
      var self;
      self = this;
      self.kukac = new Kukac;
      self.kukac.set("position", new Vector(50, 50));
      self.kukac.set("direction", new Vector(1, 0));
      return self.objects = [self.kukac];
    };

    Controller.prototype.killKukac = function() {
      var self;
      self = this;
      self.reset();
      return console.log("kill kukac");
    };

    Controller.prototype.gameOver = function() {
      this.killKukac();
      this.stopGameloop();
      return this.showMessage("<h2>Game Over!</h2> <br> Press a button to restart!");
    };

    Controller.prototype.startGameloop = function() {
      var self;
      self = this;
      self.timer = setInterval(function() {
        return self.gameloop();
      }, 1000 / self.fps);
      return this.set('paused', false);
    };

    Controller.prototype.stopGameloop = function() {
      var self;
      self = this;
      clearInterval(self.timer);
      return this.set('paused', true);
    };

    return Controller;

  })(Observable);

}).call(this);
